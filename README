This profiler is built starting from the HW1 code, which is why there's a HW1 directory containing the actual pass.
You'll also need the cache simulator at: https://github.com/jaminthorns/cpu-cache-simulator

Usage:

After cloning and entering the repo, do:

mkdir build
cd build
cmake ..
make

This should build the pass inside a build directory. Then run:

cp ../startercode/* .

This will copy useful scripts and a test function (main.c) for profiling into the build directory.
Make sure to change sim_location in profile.py in order to match the location of the cache simulator on your machine
Then you can run:

./compile.sh
./unroll.sh
./gen.sh
python profile.py

This will compile main.c, will unroll it, process it, and will generate profile data.
This profile data will be used with the cache simulator to determine the hits and misses for each memory access,
and store them in a file called hitmiss.txt

There is also a hoist/ directory, which holds the pass that will be used to process and hoist the code. This pass is unfinished.
To run the hoist code, enter the hoist/ directory.
run:

mkdir build
cd build 
cmake ..
make

This will build the hoist pass inside the hoist/build directory.

Then, copy unroll.bc and hitmiss.txt from build/ to hoist/build.
Finally, run the pass with:

opt -load HW1PASS/LLVMHW1PASS.so -hw1 unroll.bc > final.bc

NOTE:
The current main.c is built to have two hoistable instructions per loop iteration. The current hoist pass is designed
to skip every instruction in the subloops.
